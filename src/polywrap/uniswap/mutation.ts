// NOTE: This is generated by 'w3 codegen', DO NOT MODIFY

// @ts-noCheck
import { Client, InvokeApiOptions, InvokeApiResult, Uri } from '@web3api/core-js'

import * as Mutation from './mutationTypes'
import { Ethereum_TxResponse } from './types'

export interface UniswapMutationModule {
  readonly config: {
    swap(input: Mutation.Input_swap): InvokeApiOptions
    pool(input: Mutation.Input_pool): InvokeApiOptions
    execSwap(input: Mutation.Input_execSwap): InvokeApiOptions
    execPool(input: Mutation.Input_execPool): InvokeApiOptions
    execCall(input: Mutation.Input_execCall): InvokeApiOptions
    approve(input: Mutation.Input_approve): InvokeApiOptions
  }
  swap(input: Mutation.Input_swap): Promise<Ethereum_TxResponse>
  pool(input: Mutation.Input_pool): Promise<Ethereum_TxResponse>
  execSwap(input: Mutation.Input_execSwap): Promise<Ethereum_TxResponse>
  execPool(input: Mutation.Input_execPool): Promise<Ethereum_TxResponse>
  execCall(input: Mutation.Input_execCall): Promise<Ethereum_TxResponse>
  approve(input: Mutation.Input_approve): Promise<Ethereum_TxResponse>
}

export class UniswapMutationExtension implements UniswapMutationModule {
  private client: Client
  private uri: Uri

  constructor(client: Client, uri: Uri) {
    this.client = client
    this.uri = uri
  }

  readonly config = {
    swap: (input: Mutation.Input_swap): InvokeApiOptions => ({
      uri: this.uri.toString(),
      module: 'mutation',
      method: 'swap',
      input,
    }),
    pool: (input: Mutation.Input_pool): InvokeApiOptions => ({
      uri: this.uri.toString(),
      module: 'mutation',
      method: 'pool',
      input,
    }),
    execSwap: (input: Mutation.Input_execSwap): InvokeApiOptions => ({
      uri: this.uri.toString(),
      module: 'mutation',
      method: 'execSwap',
      input,
    }),
    execPool: (input: Mutation.Input_execPool): InvokeApiOptions => ({
      uri: this.uri.toString(),
      module: 'mutation',
      method: 'execPool',
      input,
    }),
    execCall: (input: Mutation.Input_execCall): InvokeApiOptions => ({
      uri: this.uri.toString(),
      module: 'mutation',
      method: 'execCall',
      input,
    }),
    approve: (input: Mutation.Input_approve): InvokeApiOptions => ({
      uri: this.uri.toString(),
      module: 'mutation',
      method: 'approve',
      input,
    }),
  }

  async swap(input: Mutation.Input_swap): Promise<Ethereum_TxResponse> {
    const options: InvokeApiOptions = this.config.swap(input)
    const result: InvokeApiResult<Ethereum_TxResponse> = await this.client.invoke<Ethereum_TxResponse>(options)
    return this.throwIfError(result)
  }

  async pool(input: Mutation.Input_pool): Promise<Ethereum_TxResponse> {
    const options: InvokeApiOptions = this.config.pool(input)
    const result: InvokeApiResult<Ethereum_TxResponse> = await this.client.invoke<Ethereum_TxResponse>(options)
    return this.throwIfError(result)
  }

  async execSwap(input: Mutation.Input_execSwap): Promise<Ethereum_TxResponse> {
    const options: InvokeApiOptions = this.config.execSwap(input)
    const result: InvokeApiResult<Ethereum_TxResponse> = await this.client.invoke<Ethereum_TxResponse>(options)
    return this.throwIfError(result)
  }

  async execPool(input: Mutation.Input_execPool): Promise<Ethereum_TxResponse> {
    const options: InvokeApiOptions = this.config.execPool(input)
    const result: InvokeApiResult<Ethereum_TxResponse> = await this.client.invoke<Ethereum_TxResponse>(options)
    return this.throwIfError(result)
  }

  async execCall(input: Mutation.Input_execCall): Promise<Ethereum_TxResponse> {
    const options: InvokeApiOptions = this.config.execCall(input)
    const result: InvokeApiResult<Ethereum_TxResponse> = await this.client.invoke<Ethereum_TxResponse>(options)
    return this.throwIfError(result)
  }

  async approve(input: Mutation.Input_approve): Promise<Ethereum_TxResponse> {
    const options: InvokeApiOptions = this.config.approve(input)
    const result: InvokeApiResult<Ethereum_TxResponse> = await this.client.invoke<Ethereum_TxResponse>(options)
    return this.throwIfError(result)
  }

  private throwIfError<T>(result: InvokeApiResult<T>): T {
    if (result.error) {
      throw result.error
    }
    if (result.data === undefined) {
      throw Error(`Polywrap client returned 'undefined', but no errors were detected`)
    }
    return result.data
  }
}
